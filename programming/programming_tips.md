= programming tips =

* Care about your craft
* Think! about your work
* Provide options, don't make lame excues
* Don't live with broken windows (bad designs, wrong decisions, poor code)
* Be a catalyst for change (stone soup vs frog soup)
* Remember the big picture
* Make quality a requirements issue
* Invest regularly in your knowledge portfolio
* Critically analyze what you hear and read
* It's both what you say and the way you say it
* DRY - don't repeat yourself
* Make it easy to reuse
* eliminate effects between unrelated things
* there are no final decisions
* use tracer bullets to find targets
* prototype to learn
* Program Close to the Problem domain
* Estimate to Avoid Surprises
* Iterate the Schedule with the Code


* Computer languages influence how you think about a problem

* Language can be used in two ways:
`Data languages` produce some form of data structure used by an application. These languages are often used to represent configuration information.

`Imperative language` is actually executed, and so can contain statements, control constructs, and the like.

* [[estimating]]
* use format which can be understood - text
* master your editor
* use source code control systems

* Debugging: Fix the Problem, Not the Blame
Embrace the fact that debugging is just problem solving, and attack it as such
In the technical arena, you want to concentrate on fixing the problem, not the blame.
It doesn't really matter whether the bug is your fault or someone else's. It is still your problem.
- Don't panic

Debugging strategies:
- visualize data
- tracing
- rubber ducking
- process of elimination
- don't assume it, prove it
- is the problem a result or symptom ?

* Learn a Text Manipulation Language - perl, python, sed, awk, shells, tcl
* write code that writes code
types of code generators:
- passive code generator: generate code once, use the result somewhere
- active code genrator: keep on generating, result is a throwaway

* You Can't Write Perfect Software

Correct program: one that does no more and no less than it claims to do

* Design with contracts - preconditions, postconditions, invariants
write shy code, defensive code
Liskov Substitution Principle: Subclasses must be usable through the base class interface without the need for the user to know the difference.

Assertive Programming

== source ==
The Pragmatic Programmer




